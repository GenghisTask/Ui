"use strict";

module.exports = KnexDataStore;

import { DataStore, Resource } from '@apidevtools/swagger-express-middleware';
import SwaggerParser from "@apidevtools/swagger-parser";
import _ from "lodash";

// Inheritance
KnexDataStore.prototype = Object.create(DataStore.prototype);
KnexDataStore.prototype.constructor = KnexDataStore;

/**
 * Use knex ORM to store REST resources in a sql database. Each collection is stored as a separate autogenerated table.
 *
 * @param   conf - Settings to connect to the database.
 * @param   swagger
 * @constructor
 * @extends DataStore
 */
function KnexDataStore (conf, swaggerFile) {
  DataStore.call(this);
  this.__connexion = require('knex')(conf);
  const parser = new SwaggerParser();
  this.__swagger = parser.dereference(swaggerFile);
}


/**
 * Export to an other datastore based on self swagger
 * 
 * @return void
 * 
 */
 KnexDataStore.prototype.export = function (dataSource, targetStore, callback) {
  
  this.__swagger.then(api=>{
    let pending = [];
    Object.keys(api.paths).filter(path=>api.paths[path]?.get?.responses?.default?.schema?.items?.properties).forEach(collectionName=>{
      pending.push(new Promise((resolve)=>{
        const launchExport = () => dataSource.getCollection(collectionName, importData);
        const importData = (_err, data) => targetStore.save(data, resolve);
        targetStore.deleteCollection(collectionName, launchExport)
      }));
    });
    Promise.all(pending).then(() => doCallback(callback, null, []));
  });
};



/**
 * Create table for a api model
 */
 KnexDataStore.prototype.createTableIfNotExists = async function(tableName, properties) {
  
  const knex = this.__connexion;
  properties.id = { 'type' : 'increments'};
  properties.createdOn = { 'type' : 'datetime'};
  properties.modifiedOn = { 'type' : 'datetime'};
  const exists = await knex.schema.hasTable(tableName);
  
  if (!exists) {
    await knex.schema.createTable(tableName, function (table) {
      Object.getOwnPropertyNames(properties).forEach((column) => {
        let fieldType = properties[column].type;
        const mapping = {
          'array':'string',
        };
        if (typeof(mapping[fieldType]) != 'undefined') {
          fieldType = mapping[fieldType];
        }
        table[fieldType](column);
      });
    });
 }
};


/**
 * Perform side effect on row
 * If one fieldType is array within object 'row', fieldValue "1,2,3" is turned into ["1","2","3"]
 *
 * @param   {string}  tableName - to look up in swagger definition
 * @param   {Object}  row - row result from database
 */
 KnexDataStore.prototype.fixArrayColumn = function (api, tableName, row)
 {
  let self = this;
  if (typeof row == 'object')
  Object.keys(row)
  .filter(column => api.definitions[tableName].properties[column].type == 'array')
  .forEach(column=>{
    if (row[column] == null) {
      row[column] = [];
      return
    }
    row[column] = row[column].split(',')
  });
 }


/**
 * Remove null from row
 *
 * @param   {Object}  row - to look up in swagger definition
 * @return   {Object}  row - row result from database
 */
 KnexDataStore.prototype.cleanDataFoundInDb = function (row)
 {
    row = Object.fromEntries(Object.entries(row).filter(([_, v]) => v != null));
    return row;
 }

/**
 * Returns the given resource.
 *
 * @param   {Resource|string}  resource - The resource (path) or Resource object to be retrieved
 * @param   {function}  callback
 * - An error-first callback.  The second parameter is the {@link Resource} object,
 * or undefined if no match was found.
 */
KnexDataStore.prototype.get = function (resource, callback) {
  let self = this;
  if (_.isString(resource)) {
    resource = new Resource(resource);
  }
  this.getTableName(resource).then(tableName => 
    this.__connexion.select().where('id', resource.name.substring(1)).table(tableName).then((rows) => {
      self.__swagger.then(api=>{
        const row = rows[0];
        self.fixArrayColumn(api, tableName, row)
        resource.merge(self.cleanDataFoundInDb(row))
        doCallback(callback, null, resource)
      });
    }).catch(()=>doCallback(callback, null, resource))
  );
};

// noinspection JSClosureCompilerSyntax
/**
 * Saves the given resource(s) to the data store.
 * If any of the resources already exist, the new data is merged with the existing data.
 *
 * @param   {...Resource|Resource[]}   resources
 * - The resource(s) or array of resources to be saved
 *
 * @param   {function}  [callback]
 * - An error-first callback.  The second parameter is the {@link Resource} object
 * or array of {@link Resource} objects that were saved.
 */
KnexDataStore.prototype.save = function (resources, callback) {
  const knex = this.__connexion;
  const pending = [];
  (_.isArray(resources)?resources:[resources]).forEach((resource) => {

    let now = Date.now();
    resource.data.createdOn = new Date(now);
    resource.data.modifiedOn = new Date(now);
    pending.push(new Promise(async (resolve, reject)=>{
      const tableName = await this.getTableName(resource);
      knex(tableName)
      .insert(resource.data)
      .onConflict('id')
      .merge(resource.data).then(resolve).catch(reject);
    }));
  });

  Promise.all(pending).then(()=>doCallback(callback, null, resources));
};

/**
 * Removes the given resource from the data store.
 *
 * @param   {...Resource|Resource[]}    resources
 * - The resource(s) or array of resources to be removed
 *
 * @param   {function}  [callback]
 * - An error-first callback.  The second parameter is the {@link Resource} object
 * or array of {@link Resource} objects that were removed.
 */
KnexDataStore.prototype.delete = function (resources, callback) {
  const knex = this.__connexion;
  const pending = [];
  (_.isArray(resources)?resources:[resources]).forEach((resource) => {
    pending.push(new Promise(async (resolve, reject)=>{
      const tableName = await this.getTableName(resource);
      knex(tableName)
      .where('id', resource.name.substring(1))
      .del().then(resolve).catch(reject);
    }));
  });
  Promise.all(pending).then(()=>doCallback(callback, null, resources));
};

/**
 * Returns all resources in the given collection.
 *
 * @param   {string}    collection
 * - The collection path (e.g. "/", "/users", "/users/jdoe/orders/")
 *
 * @param   {function}  callback
 * - An error-first callback.  The second parameter is the array of {@link Resource} objects in the collection.
 * If there are no resources for the given collection, then the array is empty.
 */
 KnexDataStore.prototype.getCollection = function (collectionName, callback) {
  let self = this;
  this.getTableName(new Resource(collectionName, "", "")).then(tableName=>
  this.__connexion.select().table(tableName).then((rows) => {
    rows.forEach(r=>{
      self.fixArrayColumn(tableName, r)
      r.data = self.cleanDataFoundInDb(r);
      r.collection = collectionName;
      r.name = r.id;
    })
    doCallback(callback, null, Resource.parse(rows))
  }).catch(()=>doCallback(callback, null, [])));
};

/**
 * Get table for given resourceName, resource, collectionName or collection
 *
 * @param   {string|Resource}        resource
 * - Resource with collection path such as "/users" or "/users/jdoe/orders/"
 *
 * @return {Promise<string>} tableName
 * - return for example "user" or "order"
 */
 KnexDataStore.prototype.getTableName = async function (resource) {
  if (_.isString(resource)) {
    resource = new Resource(resource);
  }
  const api = await this.__swagger;
  const properties = api.paths[resource.collection].get.responses.default.schema.items.properties;
  const tableName = resource.collection.substring(1).replace(/\//g, '_');
  await this.createTableIfNotExists(tableName, properties);
  return tableName;
};

/**
 * Removes all resources in the given collection.
 *
 * @param   {string}        collection
 * - The collection path (e.g. "/", "/users", "/users/jdoe/orders/")
 *
 * @param   {function}      callback
 * - An error-first callback.  The second parameter is the array of {@link Resource} objects that were deleted.
 * If nothing was deleted, then the array is empty.
 */
KnexDataStore.prototype.deleteCollection = function (collection, callback) {
  let self = this;
  this.getTableName(new Resource(collection, "", "")).then(tableName=>{
    self.__connexion(tableName).truncate().finally(()=>doCallback(callback, null, []));
  });
};



/**
 * Calls the given callback with the given arguments, if the callback is defined.
 *
 * @param   {function|*}    callback
 * @param   {Error|null}    err
 * @param   {*}             arg
 */
 function doCallback (callback, err, arg) {
  if (_.isFunction(callback)) {
    callback(err, arg);
  }
 }

export default KnexDataStore;